versione='1.0.23'
# Module: myResolve
# Author: ElSupremo
# Created on: 10.04.2021
# Last update: 28.07.2021
# License: GPL v.3 https://www.gnu.org/copyleft/gpl.html

import re, requests, sys, logging
import xbmcplugin
import xbmcgui
import xbmcaddon

addon_id = 'plugin.video.mandrakodi19'
selfAddon = xbmcaddon.Addon(id=addon_id)
debug = selfAddon.getSetting("debug")

PY3 = sys.version_info[0] == 3

def logga(mess):
    if debug == "on":
        logging.warning("MANDRA_RESOLVE: "+mess);

def rsi(parIn=None):
    chName="rsilajuve"
    chRef="zzz.php"
    if parIn == "LA1":
        chName="RsiLa1Live"
        chRef="RsiLa1.php"
    source = requests.get('https://www.janjua.tv/hembedplayer/'+chName+'/3/800/456',headers={'user-agent':'Mozilla/5.0','referer':'https://easysite.one/z/Player/embed/Native/'+chRef,'accept':'*/*'}).content
    if PY3:
        source = source.decode('utf-8')

    tok,lhtml,ids = re.findall('enableVideo.[\'"]([^\'"]+)[\w\W]+?ajax..url.+?[\'"](.+?\?(\d+))',source)[0]
    source2 = requests.get(lhtml,headers={'user-agent':'Mozilla/5.0','referer':'https://www.janjua.tv/hembedplayer/'+chName+'/3/800/456','accept':'*/*'}).content
    if PY3:
        source2 = source2.decode('utf-8')
    m3u8 = 'https://'+re.findall('=(.*)',source2)[0]+':8088/live/'+chName+'/playlist.m3u8?id=%s&pk=%s'%(ids,tok)
    return m3u8

def rocktalk(parIn=None):
    from base64 import b64encode, b64decode
    from binascii import a2b_hex
    from Cryptodome.Cipher import PKCS1_v1_5 as Cipher_PKCS1_v1_5
    from Cryptodome.Cipher import DES
    from Cryptodome.PublicKey import RSA
    from Cryptodome.Util.Padding import unpad

    user_agent = 'USER-AGENT-tvtap-APP-V2'
    headers = {
        'User-Agent': user_agent,
        'app-token': '37a6259cc0c1dae299a7866489dff0bd',
        'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8',
        'Host': 'taptube.net',
	}

    _pubkey2 = RSA.importKey(
        a2b_hex(
            "30819f300d06092a864886f70d010101050003818d003081890281"
            "8100bfa5514aa0550688ffde568fd95ac9130fcdd8825bdecc46f1"
            "8f6c6b440c3685cc52ca03111509e262dba482d80e977a938493ae"
            "aa716818efe41b84e71a0d84cc64ad902e46dbea2ec61071958826"
            "4093e20afc589685c08f2d2ae70310b92c04f9b4c27d79c8b5dbb9"
            "bd8f2003ab6a251d25f40df08b1c1588a4380a1ce8030203010001"
        )
    )

    _msg2 = a2b_hex(
        "7b224d4435223a22695757786f45684237686167747948392b58563052513d3d5c6e222c22534"
        "84131223a2242577761737941713841327678435c2f5450594a74434a4a544a66593d5c6e227d"
    )

    cipher = Cipher_PKCS1_v1_5.new(_pubkey2)	
    tkn2 =  b64encode(cipher.encrypt(_msg2))
    ch_id = parIn
    r2 = requests.post('https://rocktalk.net/tv/index.php?case=get_channel_link_with_token_latest', 
        headers=headers,
        data={"payload": tkn2, "channel_id": ch_id, "username": "603803577"},
        timeout=15)

    from pyDes import des, PAD_PKCS5
    key = b"98221122"

    links = []
    jch = r2.json()["msg"]["channel"][0]

    for stream in jch.keys():
        if "stream" in stream or "chrome_cast" in stream:
            d = des(key)
            link = d.decrypt(b64decode(jch[stream]), padmode=PAD_PKCS5)
            if link:
                link = link.decode("utf-8")
                if not link == "dummytext" and link not in links:
                    links.append((link, ""))

    return links


def myStream(parIn=None):
    video_urls = []
    page_url = "https://embed.mystream.to/"+parIn
    logga('CALL: '+page_url)
    page_data = requests.get(page_url,headers={'user-agent':'Mozilla/5.0','accept':'*/*'}).content
    if PY3:
        page_data = page_data.decode('utf-8')

    page_decode = decodeMyStream(page_data)
    video_url = preg_match(page_decode, r"'src',\s*'([^']+)")

    logga('video_url '+video_url)
    video_urls.append((video_url, ""))

    return video_urls


def decodeMyStream(data):
    # adapted from MyStream.py code - https://github.com/kodiondemand/addon/blob/master/servers/mystream.py
    first_group = preg_match(data, r'"\\"("\+.*?)"\\""\)\(\)\)\(\)')
    match = preg_match(first_group, r"(\(!\[\]\+\"\"\)\[.+?\]\+)")
    if match:
        first_group = first_group.replace(match, 'l').replace('$.__+', 't').replace('$._+', 'u').replace('$._$+', 'o')

        tmplist = []

        js = preg_match(data, r'(\$={.+?});')
        if js:
            js_group = js[3:][:-1]
            second_group = js_group.split(',')

            i = -1
            for x in second_group:
                a, b = x.split(':')

                if b == '++$':
                    i += 1
                    tmplist.append(("$.{}+".format(a), i))

                elif b == '(![]+"")[$]':
                    tmplist.append(("$.{}+".format(a), 'false'[i]))

                elif b == '({}+"")[$]':
                    tmplist.append(("$.{}+".format(a), '[object Object]'[i]))

                elif b == '($[$]+"")[$]':
                    tmplist.append(("$.{}+".format(a), 'undefined'[i]))

                elif b == '(!""+"")[$]':
                    tmplist.append(("$.{}+".format(a), 'true'[i]))

            tmplist = sorted(tmplist, key=lambda z: str(z[1]))
            for x in tmplist:
                first_group = first_group.replace(x[0], str(x[1]))

            first_group = first_group.replace('\\"', '\\').replace("\"\\\\\\\\\"", "\\\\").replace('\\"', '\\').replace('"', '').replace("+", "")

    return first_group.encode('ascii').decode('unicode-escape').encode('ascii').decode('unicode-escape')


def wizhd(parIn=None):
    video_urls = []
    page_url = "http://wizhdsports.net/"+parIn
    logga('CALL: '+page_url)
    page_data = requests.get(page_url,headers={'user-agent':'Mozilla/5.0','accept':'*/*','Referer':'http://wizhdsports.net/'}).content
    if PY3:
        page_data = page_data.decode('utf-8')

    iframe_url = preg_match(page_data, r'iframe\s*src="([^"]+)')
    logga('IFRAME: '+iframe_url)

    vUrl = findM3u8(iframe_url, page_url)
    video_urls.append((vUrl, ""))

    """
    page_data2 = requests.get(iframe_url,headers={'user-agent':'Mozilla/5.0','accept':'*/*','referer':'http://wizhdsports.net/'}).content

    if PY3:

        page_data2 = page_data2.decode('utf-8')

    video_url = preg_match(page_data2, r'source:\s*"([^"]+)')

    vUrl= video_url + '|User-Agent=Mozilla/5.0&Referer=https://www.wmsxx.com/'

    logga('video_url '+vUrl)

    video_urls.append((vUrl, ""))
    """
    return video_urls
    

def findM3u8(linkIframe, refPage):
    logga('URL: '+linkIframe)
    vUrl = ""
    try:
        page_data2 = requests.get(linkIframe,headers={'user-agent':'iPad','accept':'*/*','referer':refPage}).content

        if PY3:
            page_data2 = page_data2.decode('utf-8')

        video_url = preg_match(page_data2, r'source:\s*"([^"]+)')
        vUrl = video_url + '|User-Agent=iPad&Referer='+linkIframe
        logga('video_url '+vUrl)

    except:
        pass

    return vUrl

def daddy(parIn=None):
    video_urls = []
    logga('PAR: '+parIn)

    if (1==1):
        page_data = requests.get(parIn,headers={'user-agent':'Mozilla/5.0','accept':'*/*','Referer':'https://daddylive.me/'}).content
        if PY3:
            page_data = page_data.decode('utf-8')
        iframe_url = preg_match(page_data, r'iframe\s*src="([^"]+)')
        logga('IFRAME: '+iframe_url)
        video_url = findM3u8(iframe_url, parIn)
    else:
        video_url = GetLSProData(parIn)
        logga('video_url '+video_url)

    video_urls.append((video_url, ""))
    return video_urls

def GetLSProData(page_in, refe=None):
    import jsunpack

    logga('page_in '+page_in)
    if refe != None:
        logga('REFER '+refe)

    page_data = requests.get(page_in,headers={'user-agent':'iPad','accept':'*/*','referer':refe}).content

    if PY3:
        page_data = page_data.decode('utf-8')

    src = preg_match(page_data, '<iframe src="([^"]*)')

    if src == "":
        src = preg_match(page_data, "<iframe src='([^']*)")

    if src == "":
        src = preg_match(page_data, '<iframe width="100%" height="100%" src="([^"]*)')

    src = 'https:' + src if src.startswith('//') else src
    logga('iframe_url '+src)

    if "wigistream" in src:
        logga('iframe_wigistream_ok ')
    elif "embed" in src:
        logga('iframe_wigistream_ok ')
    else:
        logga('RECALL FUNCTION ')
        return GetLSProData(src, page_in)

    fu = requests.get(src, headers={'user-agent':'iPad','referer':page_in}).text
    find = re.findall('eval\(function(.+?.+)', fu)[0]
    unpack = jsunpack.unpack(find)
    c = re.findall('var src="([^"]*)',unpack)[0]
    return c + '|user-agent=ipad&referer=' + src

def wigi(parIn=None):

    if parIn.startswith('http'):
        wigiUrl = parIn
    else:
        wigiUrl = "https://starlive.xyz/embed.php?id="+parIn

    video_urls = []
    logga('PAR: '+parIn)
    video_url = GetLSProData(wigiUrl)
    logga('video_url '+video_url)
    video_urls.append((video_url, ""))
    return video_urls

def urlsolver(url):
    video_urls = []

    try:
        import resolveurl
    except:
        logga('NO RESOLVEURL')
        import urlresolver as resolveurl

    if resolveurl.HostedMediaFile(url).valid_url():
        resolved = resolveurl.resolve(url)
    else:
        dialog = xbmcgui.Dialog()
        mess = "Sorry, ResolveUrl does not support this domain."
        dialog.ok("Mandrakodi", mess)

        resolved = ""

    logga('video_url '+resolved)

    video_urls.append((resolved, ""))

    return video_urls

def streamingcommunity(parIn=None):
    video_urls = []

    def calculateToken():
        from time import time
        from base64 import b64encode as b64
        import hashlib

        page_video = "https://streamingcommunity.vip/client-address"
        page_data = requests.get(page_video,headers={'user-agent':'Mozilla/5.0','accept':'*/*'}).content

        if PY3:
            page_data = page_data.decode('utf-8')

        logga('IP_community '+page_data)
        o = 48
        i = 'Yc8U6r8KjAKAepEA'
        t = int(time() + (3600 * o))
        l = '{}{} {}'.format(t, page_data, i)
        md5 = hashlib.md5(l.encode())
        s = '?token={}&expires={}'.format(b64(md5.digest()).decode().replace('=', '').replace('+', "-").replace('\\', "_"), t)
        return s



    token = calculateToken()
    video_url = "https://streamingcommunity.vip/videos/master/"+parIn+"/480p"+token
    logga('video_community '+video_url)
    video_urls.append((video_url, ""))

    return video_urls



def darkIptv(parIn=None):

    video_urls = []

    video_url = "http://temporary.mine.nu:8000/movie/Direct2Movie/r3ow52c4P4/"+parIn

    if "." in parIn:

        video_url = "http://temporary.mine.nu:8000/movie/Direct2Movie/r3ow52c4P4/"+parIn

    else:

        video_url = "http://temporary.mine.nu:8000/Direct2Movie/r3ow52c4P4/"+parIn

    video_urls.append((video_url, ""))

    return video_urls





def macLink(parIn=None):
    from portal_api import PortalApi
    arrData = parIn.split("@PAR@")
    #0==>HOST
    #1==>MAC
    #2==>ID_CH

    host=arrData[0]
    mac=arrData[1]
    url=host+"?"+mac
    logga("PORTAL URL: "+url)
    portal = PortalApi(url)
    idCh=arrData[2]
    cmdCh="ffmpeg http://localhost/ch/"+idCh+"_"
    logga("PORTAL CMD: "+cmdCh)
    link = portal.get_link(cmdCh)
    logga(link)

    try:
        link = link.split(" ")[1]
    except:
        pass

    video_urls = []
    video_urls.append((link, ""))
    return video_urls



def preg_match(data, patron, index=0):
    try:
        matches = re.findall(patron, data, flags=re.DOTALL)
        return matches[index]
    except:
        return ""


def preg_match_all(data, patron, index=0):
    try:
        if index == 0:
            matches = re.search(patron, data, flags=re.DOTALL)
            if matches:
                if len(matches.groups()) == 1:
                    return matches.group(1)
                elif len(matches.groups()) > 1:
                    return matches.groups()
                else:
                    return matches.group()
            else:
                return ""
        else:
            matches = re.findall(patron, data, flags=re.DOTALL)
            return matches[index]
    except:
        return ""


def run (action, params=None):
    logga('Run version '+versione)
    commands = {
        'rsi': rsi,
        'myStream': myStream,
        'wizhd': wizhd,
        'daddy': daddy,
        'wigi': wigi,
        'risolvi': urlsolver,
        'strco': streamingcommunity,
        'dark': darkIptv,
        'mac': macLink,
        'rocktalk': rocktalk
    }

    if action in commands:
        return commands[action](params)
    else:
        raise ValueError('Invalid command: {0}!'.action)
